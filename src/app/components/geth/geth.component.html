<mat-card>
  <br/>
  <app-navigation [previous]="previousRoute" [next]="nextRoute"></app-navigation>
  <br/>
  <h1>Working with GETH</h1>
  <br />
  <p>
    <u>
      <h4><b>Download and Install Geth: </b></h4>
    </u>Download the geth from <a href="https://geth.ethereum.org/downloads" target="_blank">Download Geth</a> and install on
    to your machine.
  </p>
  <p>
    <u>
      <h4><b>Running Geth: </b></h4>
    </u> To run <i>geth</i> in windows, open a command prompt and type <b><i>geth console</i></b>. In linux or mac, run the geth
    command by opening a terminal. In this tutorial we will use windows OS.
  </p>
  <p><img src="../assets/geth/starting_geth.jpg"></p>
  <p>
    The above geth command connects to ethereum main network, runs in fast sync mode (to understand sync modes, refer How Geth
    Works section) and downloads the blocks on to your local machine. The most common scenarios that we will interact with
    the Ethereum network are creating accounts, transfering funds, deploy and interact with smartcontracts. So there is not
    really a need to download the historical data and hence runnig geth in fast sync mode is sufficient for most of the scenarios.
    We can change the default behavior of the geth by using <b><i>--syncmode flag</i></b> parameters. stop a running
    geth as daemon, use <b><i>Ctrl+D</i></b> command.
  </p>
  <p>
    Since blockchain is decentralized there is no centralized database where we can store the blocks. All the blocks get downloaded
    on the local machine where the geth is running. The path where the blocks gets stored in your computer varies based on
    OS.
  </p>
  <ul>
    <li>Windows - ~home_directory\AppData\Roaming\Ethereum</li>
    <li>Linux - ~home_directory/.ethereum</li>
    <li>Mac Os - ~home_directory/Library/Ethereum</li>
  </ul>
  <p>
    Ethereum folder will have <b><i>geth</i></b> and <b><i>keystore</i></b> sub folders. geth folder contains all the block
    data under chaindata subfolder where as keystore folder contains all your private keys, deleting keystore folder is not
    recommended.
  </p>
  <p>
    If you'd like to play around with creating Ethereum contracts, you can connect to ethereum test environment. In other words,
    instead of attaching to the main network, you can join the test network with your node, which is fully equivalent to
    the main network, but with dummy ether. You can connect to test network by using the following command:
  </p>
  <p>
    <code><b>geth --testnet console</b></code>
  </p>
  <p>
    Specifying the <b><i>--testnet flag</i></b> however will reconfigure your Geth instance a bit differently. Instead of
    using the default data directory, Geth will nest itself one level deeper into a <b>testnet</b> subfolder.
  </p>
  <ul>
    <li>Windows - ~home_directory\AppData\Roaming\Ethereum\testnet</li>
    <li>Linux - ~home_directory/.ethereum/testnet</li>
    <li>Mac Os - ~home_directory/Library/Ethereum/testnet</li>
  </ul>
  <br />
  <p>
    <u>
      <h4><b>Understanding Geth Output: </b></h4>
    </u>
    In the geth console, the log <b> starting peer-to-peer node </b> indicates the geth version that is running.
  </p>
  <p><img src="../assets/geth/geth_instance_log.jpg"></p>
  <p>
    Here the geth version is 1.7.3. Unlike node applications, there is no machanism for geth to automatically update the version.
    We will have to manually check and udate whenever there is a new version.
  </p>
  <p>
    The log <b>initialised chain configuration</b> tells us which network we have connected to. The chainID : 1 means that
    you are connected to Main network. The chain ids 1, 2 and 3 are reserved for Main and test networks. In otherwords, when
    you want to create your own blockchain network you can use any number as chainID except these.
  </p>
  <p><img src="../assets/geth/geth_chain_id_log.jpg"></p>
  <!--<p>
    The last important log is <b>IPC end point opened</b>. In windows, the IPC end point is a pipe <b><i>\\.\pipe\geth.ipc</i></b>    for linux and mac its a file. Since we started the geth without any parameters, by default, it opens IPC not Http-rpc.
    In otherwords, if you have an application which uses web3.js to connect via http-rpc, it won't work.
  </p>
  <img src="../assets/geth/geth_ipc_end_point.jpg">-->

  <br />
  <p>
    <u>
      <h4><b>Javascript Json - API: </b></h4>
    </u> We now know how to run the geth, lets connect to it so that we can interact with Javascript Json Api and hence we can
    interact with blockchain.
  </p>
  <p>
    While geth is running, open another command prompt and run <b><i>geth attach</i></b> command. Since for linux or mac
    IPC is filebase, you need to specify the location of IPC file where as in windows the IPC end point is a pipe. So for
    linux or mac the command will be <b><i>geth attach 'IPC_file_Path'</i></b>
  </p>
  <img src="../assets/geth/geth_attach.jpg">
  <p>
    Now that we are connected to geth, lets issue javascript commands to json api. For example, to create a new account issue
    personal,newAccount(); command. The json api will create an account which gets stored under ethereum home directory/keystore.
    The format of the generated key would be: UTC -- 'Time Stamp of key generation'--'key'
  </p>
  <img src="../assets/geth/create_new_account_command.jpg">
  <p>
    You can find the list of accounts exists in the network using the following command:
  </p>
  <p><code><b>personal.listAccounts</b></code></p>
  <p>
    You can transfer ether to from one account to another account by using <i><b>pesronal.sendTransaction()</b></i> method.
    SendTransaction method accepts two parameters transaction and passphrase. Transaction parameter is an object which will
    have from account, to account and value of the ether that we are transfering. Passphrase is the passphrase used for the
    verifying the transaction.
  </p>
  <p>
    <img src="../assets/geth/geth_send_transaction.jpg">
  </p>
  <p>We got an error because we dont have sufficient ether in from account to transfer</p>
  <p>
    The <i><b>personal.sign</b></i> method calculates an Ethereum specific signature with: <b>sign(keccack256("\x19Ethereum Signed Message:\n" + len(message)
    + message)))</b>. By adding a prefix to the message makes the calculated signature recognisable as an Ethereum specific
    signature. This prevents misuse where a malicious DApp can sign arbitrary data (e.g. transaction) and use the signature
    to impersonate the victim.
  </p>
  <p><img src="../assets/geth/geth_sign.jpg"></p>
  <p>
    The <i><b>personal.ecRecover</b></i> method returns the address associated with the private key that was used to calculate
    the signature in personal.sign().
  </p>
  <p><img src="../assets/geth/geth_ecRecover.jpg"></p>
  <p>Going through all the possible management API is out of scope of this tutorial, If you want learn more about API, visit
    <a href="https://github.com/ethereum/go-ethereum/wiki/Management-APIs" target="_blank">Ethereum Management API</a> and
    <a href="https://github.com/ethereum/wiki/wiki/JSON-RPC" target="_blank">Json-RPC Server</a>
  </p>
  <br/>
  <app-navigation [previous]="previousRoute" [next]="nextRoute"></app-navigation>
</mat-card>